{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { ReplaySubject, fromEvent, race, throwError, of, Observable, asyncScheduler, from } from 'rxjs';\nimport { mergeMap, map, first, mapTo, takeWhile, tap, observeOn, catchError } from 'rxjs/operators';\n\nclass JSONValidator {\n  /**\n   * Validate a JSON data against a Jsubset of the JSON Schema standard.\n   * Types are enforced to validate everything: each schema must\n   * @param data JSON data to validate\n   * @param schema Subset of JSON Schema. Must have a `type`.\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  validate(data, schema) {\n    switch (schema.type) {\n      case 'string':\n        return this.validateString(data, schema);\n\n      case 'number':\n      case 'integer':\n        return this.validateNumber(data, schema);\n\n      case 'boolean':\n        return this.validateBoolean(data, schema);\n\n      case 'array':\n        return this.validateArray(data, schema);\n\n      case 'object':\n        return this.validateObject(data, schema);\n    }\n  }\n  /**\n   * Validate a string\n   * @param data Data to validate\n   * @param schema Schema describing the string\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n\n\n  validateString(data, schema) {\n    if (typeof data !== 'string') {\n      return false;\n    }\n\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n\n    if (!this.validateEnum(data, schema)) {\n      return false;\n    }\n\n    if (schema.maxLength !== undefined && data.length > schema.maxLength) {\n      return false;\n    }\n\n    if (schema.minLength !== undefined && data.length < schema.minLength) {\n      return false;\n    }\n\n    if (schema.pattern) {\n      let regularExpression = null;\n\n      try {\n        regularExpression = new RegExp(schema.pattern);\n      } catch (_a) {// Nothing to do\n      }\n\n      if (regularExpression && !regularExpression.test(data)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Validate a number or an integer\n   * @param data Data to validate\n   * @param schema Schema describing the number or integer\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n\n\n  validateNumber(data, schema) {\n    if (typeof data !== 'number') {\n      return false;\n    }\n\n    if (schema.type === 'integer' && !Number.isInteger(data)) {\n      return false;\n    }\n\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n\n    if (!this.validateEnum(data, schema)) {\n      return false;\n    }\n    /* Test is done this way to not divide by 0 */\n\n\n    if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {\n      return false;\n    }\n\n    if (schema.maximum !== undefined && data > schema.maximum) {\n      return false;\n    }\n\n    if (schema.exclusiveMaximum !== undefined && data >= schema.exclusiveMaximum) {\n      return false;\n    }\n\n    if (schema.minimum !== undefined && data < schema.minimum) {\n      return false;\n    }\n\n    if (schema.exclusiveMinimum !== undefined && data <= schema.exclusiveMinimum) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Validate a boolean\n   * @param data Data to validate\n   * @param schema Schema describing the boolean\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n\n\n  validateBoolean(data, schema) {\n    if (typeof data !== 'boolean') {\n      return false;\n    }\n\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Validate an array\n   * @param data Data to validate\n   * @param schema Schema describing the array\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n\n\n  validateArray(data, schema) {\n    if (!Array.isArray(data)) {\n      return false;\n    }\n\n    if (schema.maxItems !== undefined && data.length > schema.maxItems) {\n      return false;\n    }\n\n    if (schema.minItems !== undefined && data.length < schema.minItems) {\n      return false;\n    }\n\n    if (schema.uniqueItems) {\n      /* Create a set to eliminate values with multiple occurences */\n      const dataSet = new Set(data);\n\n      if (data.length !== dataSet.size) {\n        return false;\n      }\n    }\n    /* Specific test for tuples */\n\n\n    if (Array.isArray(schema.items)) {\n      // TODO: cast should not be needed here\n      return this.validateTuple(data, schema.items);\n    }\n    /* Validate all the values in array */\n\n\n    for (const value of data) {\n      // TODO: remove when TypeScript 4.1 is available\n      // (currently the narrowed type from `Array.isArray()` is lost on readonly arrays)\n      if (!this.validate(value, schema.items)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Validate a tuple (array with fixed length and multiple types)\n   * @param data Data to validate\n   * @param schemas Schemas describing the tuple\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n\n\n  validateTuple(data, schemas) {\n    /* Tuples have a fixed length */\n    if (data.length !== schemas.length) {\n      return false;\n    }\n\n    for (let i = 0; i < schemas.length; i += 1) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      if (!this.validate(data[i], schemas[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Validate an object\n   * @param data Data to validate\n   * @param schema JSON schema describing the object\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n\n\n  validateObject(data, schema) {\n    /* Check the type and if not `null` as `null` also have the type `object` in old browsers */\n    if (typeof data !== 'object' || data === null) {\n      return false;\n    }\n    /* Check if the object doesn't have more properties than expected\n     * Equivalent of `additionalProperties: false`\n     */\n\n\n    if (Object.keys(schema.properties).length < Object.keys(data).length) {\n      return false;\n    }\n    /* Validate required properties */\n\n\n    if (schema.required) {\n      for (const requiredProp of schema.required) {\n        if (!Object.prototype.hasOwnProperty.call(data, requiredProp)) {\n          return false;\n        }\n      }\n    }\n    /* Recursively validate all properties */\n\n\n    for (const property in schema.properties) {\n      /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */\n      if (Object.prototype.hasOwnProperty.call(schema.properties, property) && Object.prototype.hasOwnProperty.call(data, property)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (!this.validate(data[property], schema.properties[property])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Validate a constant\n   * @param data Data ta validate\n   * @param schema JSON schema describing the constant\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n\n\n  validateConst(data, schema) {\n    if (!schema.const) {\n      return true;\n    }\n\n    return data === schema.const;\n  }\n  /**\n   * Validate an enum\n   * @param data Data ta validate\n   * @param schema JSON schema describing the enum\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n\n\n  validateEnum(data, schema) {\n    if (!schema.enum) {\n      return true;\n    }\n    /* Cast as the data can be of multiple types, and so TypeScript is lost */\n\n\n    return schema.enum.includes(data);\n  }\n\n}\n\nJSONValidator.ɵfac = function JSONValidator_Factory(t) {\n  return new (t || JSONValidator)();\n};\n\nJSONValidator.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JSONValidator,\n  factory: JSONValidator.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JSONValidator, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * Token to provide a prefix to `localStorage` keys.\n */\n\n\nconst LS_PREFIX = new InjectionToken('localStoragePrefix', {\n  providedIn: 'root',\n  factory: () => ''\n});\n/**\n * Default name used for `indexedDB` database.\n */\n\nconst DEFAULT_IDB_DB_NAME = 'ngStorage';\n/**\n * Token to provide `indexedDB` database name.\n */\n\nconst IDB_DB_NAME = new InjectionToken('localStorageIDBDBName', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_DB_NAME\n});\n/**\n * Default version used for `indexedDB` database.\n */\n\nconst DEFAULT_IDB_DB_VERSION = 1;\n/**\n * Token to provide `indexedDB` database version.\n * Must be an unsigned **integer**.\n */\n\nconst IDB_DB_VERSION = new InjectionToken('localStorageIDBDBVersion', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_DB_VERSION\n});\n/**\n * Default name used for `indexedDB` object store.\n */\n\nconst DEFAULT_IDB_STORE_NAME = 'localStorage';\n/**\n * Token to provide `indexedDB` store name.\n * For backward compatibility, the default can't be set now, `IndexedDBDatabase` will do it at runtime.\n */\n\nconst IDB_STORE_NAME = new InjectionToken('localStorageIDBStoreName', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_STORE_NAME\n});\n/**\n * Default value for interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n */\n\nconst DEFAULT_IDB_NO_WRAP = true;\n/**\n * Token to allow interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n */\n\nconst IDB_NO_WRAP = new InjectionToken('localStorageIDBWrap', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_NO_WRAP\n});\n/**\n * Exception message when `indexedDB` is not working\n */\n\nconst IDB_BROKEN_ERROR = 'indexedDB is not working';\n/**\n * Exception raised when `indexedDB` is not working\n */\n\nclass IDBBrokenError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = IDB_BROKEN_ERROR;\n  }\n\n}\n/**\n * Exception message when a value can't be serialized for `localStorage`\n */\n\n\nconst SERIALIZATION_ERROR = `The storage is currently localStorage,\nwhere data must be serialized, and the provided data can't be serialized.`;\n/**\n * Exception raised when a value can't be serialized for `localStorage`\n */\n\nclass SerializationError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = SERIALIZATION_ERROR;\n  }\n\n}\n\nclass IndexedDBDatabase {\n  /**\n   * Constructor params are provided by Angular (but can also be passed manually in tests)\n   * @param dbName `indexedDB` database name\n   * @param storeName `indexedDB` store name\n   * @param dbVersion `indexedDB` database version\n   * @param noWrap Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility\n   */\n  constructor(dbName = DEFAULT_IDB_DB_NAME, storeName = DEFAULT_IDB_STORE_NAME, dbVersion = DEFAULT_IDB_DB_VERSION, noWrap = DEFAULT_IDB_NO_WRAP) {\n    /**\n     * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection\n     * even after the connection success event happened\n     */\n    this.database = new ReplaySubject(1);\n    /**\n     * Index used when wrapping value. *For backward compatibility only.*\n     */\n\n    this.wrapIndex = 'value';\n    this.dbName = dbName;\n    this.storeName = storeName;\n    this.dbVersion = dbVersion;\n    this.noWrap = noWrap;\n    /* Connect to `indexedDB`, with prefix if provided by the user */\n\n    this.connect();\n  }\n  /**\n   * Information about `indexedDB` connection. *Only useful for interoperability.*\n   * @returns `indexedDB` database name, store name and database version\n   */\n\n\n  get backingStore() {\n    return {\n      database: this.dbName,\n      store: this.storeName,\n      version: this.dbVersion\n    };\n  }\n  /**\n   * Number of items in our `indexedDB` database and object store\n   */\n\n\n  get size() {\n    /* Open a transaction in read-only mode */\n    return this.transaction('readonly').pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Request to know the number of items */\n\n      const request = store.count();\n      /* Return the result */\n\n      return events.pipe(map(() => request.result));\n    }),\n    /* The observable will complete after the first value */\n    first());\n  }\n  /**\n   * Gets an item value in our `indexedDB` store\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`\n   */\n\n\n  get(key) {\n    /* Open a transaction in read-only mode */\n    return this.transaction('readonly').pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Request the value with the key provided by the user */\n\n      const request = store.get(key);\n      /* Listen events and return the result */\n\n      return events.pipe(map(() => {\n        if (request.result !== undefined && request.result !== null) {\n          /* Prior to v8, the value was wrapped in an `{ value: ...}` object */\n          if (!this.noWrap && typeof request.result === 'object' && this.wrapIndex in request.result && // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          request.result[this.wrapIndex] !== undefined && request.result[this.wrapIndex] !== null) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            return request.result[this.wrapIndex];\n          } else {\n            /* Cast to the wanted type */\n            return request.result;\n          }\n        }\n        /* Return `undefined` if the value is empty */\n\n\n        return undefined;\n      }));\n    }),\n    /* The observable will complete after the first value */\n    first());\n  }\n  /**\n   * Sets an item in our `indexedDB` store\n   * @param key The item's key\n   * @param data The item's value\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n\n\n  set(key, data) {\n    /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */\n    if (data === undefined) {\n      return this.delete(key);\n    }\n    /* Open a transaction in write mode */\n\n\n    return this.transaction('readwrite').pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Prior to v8, data was wrapped in a `{ value: ... }` object */\n\n      const dataToStore = this.noWrap ? data : {\n        [this.wrapIndex]: data\n      };\n      /* Add if the item is not existing yet, or update otherwise */\n\n      store.put(dataToStore, key);\n      /* Listen to events and return `undefined` as no value is expected */\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\n      return events.pipe(mapTo(undefined));\n    }),\n    /* The observable will complete after the first value */\n    first());\n  }\n  /**\n   * Deletes an item in our `indexedDB` store\n   * @param key The item's key\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n\n\n  delete(key) {\n    /* Open a transaction in write mode */\n    return this.transaction('readwrite').pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Delete the item in store */\n\n      store.delete(key);\n      /* Listen to events and return `undefined` as no data is expected here */\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\n      return events.pipe(mapTo(undefined));\n    }),\n    /* The observable will complete after the first value */\n    first());\n  }\n  /**\n   * Deletes all items from our `indexedDB` objet store\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n\n\n  clear() {\n    /* Open a transaction in write mode */\n    return this.transaction('readwrite').pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Delete all items in object store */\n\n      store.clear();\n      /* Listen to events and return `undefined` as no data is expected here */\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\n      return events.pipe(mapTo(undefined));\n    }),\n    /* The observable will complete */\n    first());\n  }\n  /**\n   * Get all the keys in our `indexedDB` store\n   * @returns An RxJS `Observable` iterating on each key\n   */\n\n\n  keys() {\n    /* Open a transaction in read-only mode */\n    return this.transaction('readonly').pipe(\n    /* `first()` is used as the final operator in other methods to complete the `Observable`\n     * (as it all starts from a `ReplaySubject` which never ends),\n     * but as this method is iterating over multiple values, `first()` **must** be used here */\n    first(), mergeMap(transactionData => {\n      const {\n        store\n      } = transactionData;\n      /* Open a cursor on the store\n       * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */\n\n      const request = store.openKeyCursor();\n      /* Listen to success event */\n\n      const success$ = fromEvent(request, 'success').pipe(\n      /* Stop the `Observable` when the cursor is `null` */\n      takeWhile(() => request.result !== null),\n      /* This lib only allows string keys, but user could have added other types of keys from outside\n       * It's OK to cast as the cursor as been tested in the previous operator */\n      map(() => request.result.key.toString()),\n      /* Iterate on the cursor */\n      tap(() => {\n        request.result.continue();\n      }));\n      /* Listen to error event and if so, throw an error */\n\n      const error$ = this.listenError(request);\n      /* Choose the first event to occur */\n\n      return race([success$, error$]);\n    }));\n  }\n  /**\n   * Check if a key exists in our `indexedDB` store\n   * @returns An RxJS `Observable` telling if the key exists or not\n   */\n\n\n  has(key) {\n    /* Open a transaction in read-only mode */\n    return this.transaction('readonly').pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Check if the key exists in the store\n       * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69\n       */\n\n      const request = store.getKey(key);\n      /* Listen to events and return `true` or `false` */\n\n      return events.pipe(map(() => request.result !== undefined ? true : false));\n    }),\n    /* The observable will complete */\n    first());\n  }\n  /**\n   * Connects to `indexedDB` and creates the object store on first time\n   */\n\n\n  connect() {\n    let request;\n    /* Connect to `indexedDB`\n     * Will fail in Safari cross-origin iframes\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */\n\n    try {\n      /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */\n      request = indexedDB.open(this.dbName, this.dbVersion);\n    } catch (_a) {\n      this.database.error(new IDBBrokenError());\n      return;\n    }\n    /* Create store on first connection */\n\n\n    this.createStore(request);\n    /* Listen to success and error events */\n\n    const success$ = fromEvent(request, 'success');\n    const error$ = this.listenError(request);\n    /* Choose the first to occur */\n\n    race([success$, error$])\n    /* The observable will complete */\n    .pipe(first()).subscribe({\n      next: () => {\n        /* Register the database connection in the `ReplaySubject` for further access */\n        this.database.next(request.result);\n      },\n      error: () => {\n        /* Firefox private mode issue: fallback storage if IndexedDb connection is failing\n        * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n        * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */\n        this.database.error(new IDBBrokenError());\n      }\n    });\n  }\n  /**\n   * Create store on first use of `indexedDB`\n   * @param request `indexedDB` database opening request\n   */\n\n\n  createStore(request) {\n    /* Listen to the event fired on first connection */\n    fromEvent(request, 'upgradeneeded')\n    /* The observable will complete */\n    .pipe(first()).subscribe({\n      next: () => {\n        /* Check if the store already exists, to avoid error */\n        if (!request.result.objectStoreNames.contains(this.storeName)) {\n          /* Create the object store */\n          request.result.createObjectStore(this.storeName);\n        }\n      }\n    });\n  }\n  /**\n   * Open an `indexedDB` transaction and get our store\n   * @param mode `readonly` or `readwrite`\n   * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`\n   */\n\n\n  transaction(mode) {\n    /* From the `indexedDB` connection, open a transaction and get the store */\n    return this.database.pipe(mergeMap(database => {\n      let transaction;\n\n      try {\n        transaction = database.transaction([this.storeName], mode);\n      } catch (error) {\n        /* The store could have been deleted from outside */\n        return throwError(error);\n      }\n      /* Get the store from the transaction */\n\n\n      const store = transaction.objectStore(this.storeName);\n      /* Listen transaction `complete` and `error` events */\n\n      const events = this.listenTransactionEvents(transaction);\n      return of({\n        store,\n        events\n      });\n    }));\n  }\n  /**\n   * Listen errors on a transaction or request, and throw if trigerred\n   * @param transactionOrRequest `indexedDb` transaction or request to listen\n   * @returns An `Observable` listening to errors\n   */\n\n\n  listenError(transactionOrRequest) {\n    return fromEvent(transactionOrRequest, 'error').pipe(\n    /* Throw on error to be able to catch errors in RxJS way.\n     * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`\n     * if we are on the request and the error is only triggered later by the transaction */\n    mergeMap(event => throwError(event.target.error)));\n  }\n  /**\n   * Listen transaction `complete` and `error` events\n   * @param transaction Transaction to listen\n   * @returns An `Observable` listening to transaction `complete` and `error` events\n   */\n\n\n  listenTransactionEvents(transaction) {\n    /* Listen to the `complete` event */\n    const complete$ = fromEvent(transaction, 'complete');\n    /* Listen to the `error` event */\n\n    const error$ = this.listenError(transaction);\n    /* Choose the first event to occur */\n\n    return race([complete$, error$]);\n  }\n\n}\n\nIndexedDBDatabase.ɵfac = function IndexedDBDatabase_Factory(t) {\n  return new (t || IndexedDBDatabase)(i0.ɵɵinject(IDB_DB_NAME), i0.ɵɵinject(IDB_STORE_NAME), i0.ɵɵinject(IDB_DB_VERSION), i0.ɵɵinject(IDB_NO_WRAP));\n};\n\nIndexedDBDatabase.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IndexedDBDatabase,\n  factory: IndexedDBDatabase.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IndexedDBDatabase, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [IDB_DB_NAME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [IDB_STORE_NAME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [IDB_DB_VERSION]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [IDB_NO_WRAP]\n      }]\n    }];\n  }, null);\n})();\n\nclass LocalStorageDatabase {\n  /**\n   * Constructor params are provided by Angular (but can also be passed manually in tests)\n   * @param prefix Prefix option to avoid collision for multiple apps on the same subdomain or for interoperability\n   */\n  constructor(prefix = '') {\n    /* Prefix if asked, or no prefix otherwise */\n    this.prefix = prefix || '';\n  }\n  /**\n   * Number of items in `localStorage`\n   */\n\n\n  get size() {\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(localStorage.length);\n  }\n  /**\n   * Gets an item value in `localStorage`\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n   */\n\n\n  get(key) {\n    /* Get raw data */\n    const unparsedData = localStorage.getItem(this.prefixKey(key));\n    let parsedData;\n    /* No need to parse if data is `null` or `undefined` */\n\n    if (unparsedData !== undefined && unparsedData !== null) {\n      /* Try to parse */\n      try {\n        parsedData = JSON.parse(unparsedData);\n      } catch (error) {\n        return throwError(error);\n      }\n    }\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n\n    return of(parsedData);\n  }\n  /**\n   * Store an item in `localStorage`\n   * @param key The item's key\n   * @param data The item's value\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n\n\n  set(key, data) {\n    let serializedData = null;\n    /* Check if data can be serialized */\n\n    const dataPrototype = Object.getPrototypeOf(data);\n\n    if (typeof data === 'object' && data !== null && !Array.isArray(data) && !(dataPrototype === Object.prototype || dataPrototype === null)) {\n      return throwError(new SerializationError());\n    }\n    /* Try to stringify (can fail on circular references) */\n\n\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return throwError(error);\n    }\n    /* Can fail if storage quota is exceeded */\n\n\n    try {\n      localStorage.setItem(this.prefixKey(key), serializedData);\n    } catch (error) {\n      return throwError(error);\n    }\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n\n    return of(undefined);\n  }\n  /**\n   * Deletes an item in `localStorage`\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n\n\n  delete(key) {\n    localStorage.removeItem(this.prefixKey(key));\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n    return of(undefined);\n  }\n  /**\n   * Deletes all items in `localStorage`\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n\n\n  clear() {\n    localStorage.clear();\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n    return of(undefined);\n  }\n  /**\n   * Get all keys in `localStorage`\n   * Note the order of the keys may be inconsistent in Firefox\n   * @returns A RxJS `Observable` iterating on keys\n   */\n\n\n  keys() {\n    /* Create an `Observable` from keys */\n    return new Observable(subscriber => {\n      /* Iteretate over all the indexes */\n      for (let index = 0; index < localStorage.length; index += 1) {\n        /* Cast as we are sure in this case the key is not `null` */\n        subscriber.next(this.getUnprefixedKey(index));\n      }\n\n      subscriber.complete();\n    }).pipe(\n    /* Required to work like other databases which are asynchronous */\n    observeOn(asyncScheduler));\n  }\n  /**\n   * Check if a key exists in `localStorage`\n   * @param key The item's key\n   * @returns A RxJS `Observable` telling if the key exists or not\n   */\n\n\n  has(key) {\n    /* Itérate over all indexes in storage */\n    for (let index = 0; index < localStorage.length; index += 1) {\n      if (key === this.getUnprefixedKey(index)) {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(true);\n      }\n    }\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n\n    return of(false);\n  }\n  /**\n   * Get an unprefixed key\n   * @param index Index of the key\n   * @returns The unprefixed key name if exists, `null` otherwise\n   */\n\n\n  getUnprefixedKey(index) {\n    /* Get the key in storage: may have a prefix */\n    const prefixedKey = localStorage.key(index);\n\n    if (prefixedKey !== null) {\n      /* If no prefix, the key is already good, otherwrite strip the prefix */\n      return !this.prefix ? prefixedKey : prefixedKey.substr(this.prefix.length);\n    }\n\n    return null;\n  }\n  /**\n   * Add the prefix to a key\n   * @param key The key name\n   * @returns The prefixed key name\n   */\n\n\n  prefixKey(key) {\n    return `${this.prefix}${key}`;\n  }\n\n}\n\nLocalStorageDatabase.ɵfac = function LocalStorageDatabase_Factory(t) {\n  return new (t || LocalStorageDatabase)(i0.ɵɵinject(LS_PREFIX));\n};\n\nLocalStorageDatabase.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LocalStorageDatabase,\n  factory: LocalStorageDatabase.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalStorageDatabase, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [LS_PREFIX]\n      }]\n    }];\n  }, null);\n})();\n\nclass MemoryDatabase {\n  constructor() {\n    /**\n     * Memory storage\n     */\n    this.memoryStorage = new Map();\n  }\n  /**\n   * Number of items in memory\n   */\n\n\n  get size() {\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.size);\n  }\n  /**\n   * Gets an item value in memory\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n   */\n\n\n  get(key) {\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.get(key));\n  }\n  /**\n   * Sets an item in memory\n   * @param key The item's key\n   * @param data The item's value\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n\n\n  set(key, data) {\n    this.memoryStorage.set(key, data);\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n    return of(undefined);\n  }\n  /**\n   * Deletes an item in memory\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n\n\n  delete(key) {\n    this.memoryStorage.delete(key);\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n    return of(undefined);\n  }\n  /**\n   * Deletes all items in memory\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n\n\n  clear() {\n    this.memoryStorage.clear();\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n    return of(undefined);\n  }\n  /**\n   * Get all keys in memory\n   * @returns A RxJS `Observable` iterating on keys\n   */\n\n\n  keys() {\n    /* Create an `Observable` from keys */\n    return from(this.memoryStorage.keys());\n  }\n  /**\n   * Check if a key exists in memory\n   * @param key Key name\n   * @returns a RxJS `Observable` telling if the key exists or not\n   */\n\n\n  has(key) {\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.has(key));\n  }\n\n}\n\nMemoryDatabase.ɵfac = function MemoryDatabase_Factory(t) {\n  return new (t || MemoryDatabase)();\n};\n\nMemoryDatabase.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: MemoryDatabase,\n  factory: MemoryDatabase.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MemoryDatabase, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * Factory to create a storage according to browser support\n * @param platformId Context about the platform (`browser`, `server`...)\n * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain\n * @param IDBDBName `indexedDB` database name\n * @param IDBstoreName `indexedDB` storeName name\n * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}\n */\n\n\nfunction localDatabaseFactory(platformId, LSPrefix, IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap) {\n  /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n   * just trying to check `indexedDB` or `localStorage` variables causes a security exception.\n   * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n   */\n  try {\n    // Do not explicit `window` here, as the global object is not the same in web workers\n    if (isPlatformBrowser(platformId) && indexedDB !== undefined && indexedDB !== null && 'open' in indexedDB) {\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - it could exist but be `undefined` or `null`\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - All other browsers in normal mode\n      * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */\n      return new IndexedDBDatabase(IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap);\n    } else if (isPlatformBrowser(platformId) && localStorage !== undefined && localStorage !== null && 'getItem' in localStorage) {\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - if `localStorage` exists (to be sure)\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}\n      * - Firefox private mode, but in this case, data will be swiped when the user leaves the app\n      * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n      */\n      return new LocalStorageDatabase(LSPrefix);\n    }\n  } catch (_a) {// Nothing to do\n  }\n  /* Will be the case for:\n   * - In browsers if storage has been fully disabled (via the \"Block all cookies\" option)\n   * - Server-side rendering\n   * - All other non-browser context\n   */\n\n\n  return new MemoryDatabase();\n}\n\nclass LocalDatabase {}\n\nLocalDatabase.ɵfac = function LocalDatabase_Factory(t) {\n  return new (t || LocalDatabase)();\n};\n\nLocalDatabase.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LocalDatabase,\n  factory: function LocalDatabase_Factory(t) {\n    let r = null;\n\n    if (t) {\n      r = new t();\n    } else {\n      r = localDatabaseFactory(i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(LS_PREFIX), i0.ɵɵinject(IDB_DB_NAME), i0.ɵɵinject(IDB_STORE_NAME), i0.ɵɵinject(IDB_DB_VERSION), i0.ɵɵinject(IDB_NO_WRAP));\n    }\n\n    return r;\n  },\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalDatabase, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: localDatabaseFactory,\n      deps: [PLATFORM_ID, LS_PREFIX, IDB_DB_NAME, IDB_STORE_NAME, IDB_DB_VERSION, IDB_NO_WRAP]\n    }]\n  }], null, null);\n})();\n/**\n * Exception message when a value is not valid against the JSON schema\n */\n\n\nconst VALIDATION_ERROR = `Data stored is not valid against the provided JSON schema.\nCheck your JSON schema, otherwise it means data has been corrupted.`;\n/**\n * Exception raised when a value is not valid against the JSON schema\n */\n\nclass ValidationError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = VALIDATION_ERROR;\n  }\n\n}\n\nclass StorageMap {\n  /**\n   * Constructor params are provided by Angular (but can also be passed manually in tests)\n   * @param database Storage to use\n   * @param jsonValidator Validator service\n   * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability\n   */\n  constructor(database, jsonValidator = new JSONValidator(), LSPrefix = '') {\n    this.database = database;\n    this.jsonValidator = jsonValidator;\n    this.LSPrefix = LSPrefix;\n    this.notifiers = new Map();\n  }\n  /**\n   * **Number of items** in storage, wrapped in an `Observable`.\n   *\n   * @example\n   * this.storageMap.size.subscribe((size) => {\n   *   console.log(size);\n   * });\n   */\n\n\n  get size() {\n    return this.database.size\n    /* Catch if `indexedDb` is broken */\n    .pipe(this.catchIDBBroken(() => this.database.size));\n  }\n  /**\n   * Tells you which storage engine is used. *Only useful for interoperability.*\n   * Note that due to some browsers issues in some special contexts\n   * (Firefox private mode and Safari cross-origin iframes),\n   * **this information may be wrong at initialization,**\n   * as the storage could fallback from `indexedDB` to `localStorage`\n   * only after a first read or write operation.\n   * @returns Storage engine used\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'indexedDB') {}\n   */\n\n\n  get backingEngine() {\n    if (this.database instanceof IndexedDBDatabase) {\n      return 'indexedDB';\n    } else if (this.database instanceof LocalStorageDatabase) {\n      return 'localStorage';\n    } else if (this.database instanceof MemoryDatabase) {\n      return 'memory';\n    } else {\n      return 'unknown';\n    }\n  }\n  /**\n   * Info about `indexedDB` database. *Only useful for interoperability.*\n   * @returns `indexedDB` database name, store name and database version.\n   * **Values will be empty if the storage is not `indexedDB`,**\n   * **so it should be used after an engine check**.\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'indexedDB') {\n   *   const { database, store, version } = this.storageMap.backingStore;\n   * }\n   */\n\n\n  get backingStore() {\n    return this.database instanceof IndexedDBDatabase ? this.database.backingStore : {\n      database: '',\n      store: '',\n      version: 0\n    };\n  }\n  /**\n   * Info about `localStorage` fallback storage. *Only useful for interoperability.*\n   * @returns `localStorage` prefix.\n   * **Values will be empty if the storage is not `localStorage`,**\n   * **so it should be used after an engine check**.\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'localStorage') {\n   *   const { prefix } = this.storageMap.fallbackBackingStore;\n   * }\n   */\n\n\n  get fallbackBackingStore() {\n    return this.database instanceof LocalStorageDatabase ? {\n      prefix: this.database.prefix\n    } : {\n      prefix: ''\n    };\n  }\n\n  get(key, schema) {\n    /* Get the data in storage */\n    return this.database.get(key).pipe(\n    /* Check if `indexedDb` is broken */\n    this.catchIDBBroken(() => this.database.get(key)), mergeMap(data => {\n      /* No need to validate if the data is empty */\n      if (data === undefined || data === null) {\n        return of(undefined);\n      } else if (schema) {\n        /* Validate data against a JSON schema if provided */\n        if (!this.jsonValidator.validate(data, schema)) {\n          return throwError(new ValidationError());\n        }\n        /* Data have been checked, so it's OK to cast */\n\n\n        return of(data);\n      }\n      /* Cast to unknown as the data wasn't checked */\n\n\n      return of(data);\n    }));\n  }\n  /**\n   * Set an item in storage.\n   * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n   * @param key The item's key\n   * @param data The item's value\n   * @param schema Optional JSON schema to validate the data\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.set('key', 'value').subscribe(() => {});\n   */\n\n\n  set(key, data, schema) {\n    /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,\n     * so removing item instead for all storages to have a consistent API */\n    if (data === undefined || data === null) {\n      return this.delete(key);\n    }\n    /* Validate data against a JSON schema if provided */\n\n\n    if (schema && !this.jsonValidator.validate(data, schema)) {\n      return throwError(new ValidationError());\n    }\n\n    return this.database.set(key, data).pipe(\n    /* Catch if `indexedDb` is broken */\n    this.catchIDBBroken(() => this.database.set(key, data)),\n    /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n    tap(() => {\n      this.notify(key, data);\n    }));\n  }\n  /**\n   * Delete an item in storage\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.delete('key').subscribe(() => {});\n   */\n\n\n  delete(key) {\n    return this.database.delete(key).pipe(\n    /* Catch if `indexedDb` is broken */\n    this.catchIDBBroken(() => this.database.delete(key)),\n    /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n    tap(() => {\n      this.notify(key, undefined);\n    }));\n  }\n  /**\n   * Delete all items in storage\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.clear().subscribe(() => {});\n   */\n\n\n  clear() {\n    return this.database.clear().pipe(\n    /* Catch if `indexedDb` is broken */\n    this.catchIDBBroken(() => this.database.clear()),\n    /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n    tap(() => {\n      for (const key of this.notifiers.keys()) {\n        this.notify(key, undefined);\n      }\n    }));\n  }\n  /**\n   * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:\n   * * if there is no key, the `next` callback will not be invoked,\n   * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,\n   * as this `Observable` can emit several values and so will invoke the `next` callback several times.\n   * @returns A list of the keys wrapped in a RxJS `Observable`\n   *\n   * @example\n   * this.storageMap.keys().subscribe({\n   *   next: (key) => { console.log(key); },\n   *   complete: () => { console.log('Done'); },\n   * });\n   */\n\n\n  keys() {\n    return this.database.keys()\n    /* Catch if `indexedDb` is broken */\n    .pipe(this.catchIDBBroken(() => this.database.keys()));\n  }\n  /**\n   * Tells if a key exists in storage\n   * @returns A RxJS `Observable` telling if the key exists\n   *\n   * @example\n   * this.storageMap.has('key').subscribe((hasKey) => {\n   *   if (hasKey) {}\n   * });\n   */\n\n\n  has(key) {\n    return this.database.has(key)\n    /* Catch if `indexedDb` is broken */\n    .pipe(this.catchIDBBroken(() => this.database.has(key)));\n  }\n\n  watch(key, schema) {\n    /* Check if there is already a notifier */\n    if (!this.notifiers.has(key)) {\n      this.notifiers.set(key, new ReplaySubject(1));\n    }\n    /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    const notifier = this.notifiers.get(key);\n    /* Get the current item value */\n\n    (schema ? this.get(key, schema) : this.get(key)).subscribe({\n      next: result => notifier.next(result),\n      error: error => notifier.error(error)\n    });\n    /* Only the public API of the `Observable` should be returned */\n\n    return schema ? notifier.asObservable() : notifier.asObservable();\n  }\n  /**\n   * Notify when a value changes\n   * @param key The item's key\n   * @param data The new value\n   */\n\n\n  notify(key, value) {\n    const notifier = this.notifiers.get(key);\n\n    if (notifier) {\n      notifier.next(value);\n    }\n  }\n  /**\n   * RxJS operator to catch if `indexedDB` is broken\n   * @param operationCallback Callback with the operation to redo\n   */\n\n\n  catchIDBBroken(operationCallback) {\n    return catchError(error => {\n      /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */\n      if (error !== undefined && error !== null && typeof error === 'object' && 'message' in error // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      && error.message === IDB_BROKEN_ERROR) {\n        /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n         * just trying to check `localStorage` variable causes a security exception.\n         * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n         */\n        try {\n          if ('getItem' in localStorage) {\n            /* Fallback to `localStorage` if available */\n            this.database = new LocalStorageDatabase(this.LSPrefix);\n          } else {\n            /* Fallback to memory storage otherwise */\n            this.database = new MemoryDatabase();\n          }\n        } catch (_a) {\n          /* Fallback to memory storage otherwise */\n          this.database = new MemoryDatabase();\n        }\n        /* Redo the operation */\n\n\n        return operationCallback();\n      } else {\n        /* Otherwise, rethrow the error */\n        return throwError(error);\n      }\n    });\n  }\n\n}\n\nStorageMap.ɵfac = function StorageMap_Factory(t) {\n  return new (t || StorageMap)(i0.ɵɵinject(LocalDatabase), i0.ɵɵinject(JSONValidator), i0.ɵɵinject(LS_PREFIX));\n};\n\nStorageMap.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StorageMap,\n  factory: StorageMap.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StorageMap, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: LocalDatabase\n    }, {\n      type: JSONValidator\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [LS_PREFIX]\n      }]\n    }];\n  }, null);\n})();\n\nclass LocalStorage {\n  /* Use the `StorageMap` service to avoid code duplication */\n  constructor(storageMap) {\n    this.storageMap = storageMap;\n  }\n  /**\n   * Number of items in storage wrapped in an `Observable`\n   *\n   * @example\n   * this.localStorage.length.subscribe((length) => {\n   *   console.log(length);\n   * });\n   */\n\n\n  get length() {\n    return this.storageMap.size;\n  }\n\n  getItem(key, schema) {\n    if (schema) {\n      /* Backward compatibility with version <= 7 */\n      schema = 'schema' in schema ? schema.schema : schema;\n    }\n\n    return (schema ? this.storageMap.get(key, schema) : this.storageMap.get(key)).pipe(\n    /* Transform `undefined` into `null` to align with `localStorage` API */\n    map(value => value !== undefined ? value : null));\n  }\n  /**\n   * Set an item in storage.\n   * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n   * @param key The item's key\n   * @param data The item's value\n   * @param schema Optional JSON schema to validate the data\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.localStorage.set('key', 'value').subscribe(() => {});\n   */\n\n\n  setItem(key, data, schema) {\n    return this.storageMap.set(key, data, schema).pipe(\n    /* Transform `undefined` into `true` for backward compatibility with v7 */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    mapTo(true));\n  }\n  /**\n   * Delete an item in storage\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.localStorage.delete('key').subscribe(() => {});\n   */\n\n\n  removeItem(key) {\n    return this.storageMap.delete(key).pipe(\n    /* Transform `undefined` into `true` for backward compatibility with v7 */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    mapTo(true));\n  }\n  /**\n   * Delete all items in storage\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.localStorage.clear().subscribe(() => {});\n   */\n\n\n  clear() {\n    return this.storageMap.clear().pipe(\n    /* Transform `undefined` into `true` for backward compatibility with v7 */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    mapTo(true));\n  }\n\n}\n\nLocalStorage.ɵfac = function LocalStorage_Factory(t) {\n  return new (t || LocalStorage)(i0.ɵɵinject(StorageMap));\n};\n\nLocalStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LocalStorage,\n  factory: LocalStorage.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalStorage, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: StorageMap\n    }];\n  }, null);\n})();\n/**\n * This module does not contain anything, it's only useful to provide options via `.forRoot()`.\n */\n\n\nclass StorageModule {\n  /**\n   * Only useful to provide options, otherwise it does nothing.\n   * **Must be used at initialization, ie. in `AppModule`, and must not be loaded again in another module.**\n   *\n   * @example\n   * NgModule({\n   *   imports: [StorageModule.forRoot({\n   *     LSPrefix: 'custom_',\n   *   })]\n   * })\n   * export class AppModule\n   */\n  static forRoot(config) {\n    return {\n      ngModule: StorageModule,\n      providers: [config.LSPrefix ? {\n        provide: LS_PREFIX,\n        useValue: config.LSPrefix\n      } : [], config.IDBDBName ? {\n        provide: IDB_DB_NAME,\n        useValue: config.IDBDBName\n      } : [], config.IDBStoreName ? {\n        provide: IDB_STORE_NAME,\n        useValue: config.IDBStoreName\n      } : [], config.IDBDBVersion ? {\n        provide: IDB_DB_VERSION,\n        useValue: config.IDBDBVersion\n      } : [], config.IDBNoWrap === false ? {\n        provide: IDB_NO_WRAP,\n        useValue: config.IDBNoWrap\n      } : []]\n    };\n  }\n\n}\n\nStorageModule.ɵfac = function StorageModule_Factory(t) {\n  return new (t || StorageModule)();\n};\n\nStorageModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: StorageModule\n});\nStorageModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StorageModule, [{\n    type: NgModule\n  }], null, null);\n})();\n/*\n * Public API Surface of local-storage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { JSONValidator, LocalDatabase, LocalStorage, SERIALIZATION_ERROR, SerializationError, StorageMap, StorageModule, VALIDATION_ERROR, ValidationError };","map":{"version":3,"sources":["D:/webform-frontend/node_modules/@ngx-pwa/local-storage/fesm2015/ngx-pwa-local-storage.mjs"],"names":["i0","Injectable","InjectionToken","Inject","PLATFORM_ID","NgModule","isPlatformBrowser","ReplaySubject","fromEvent","race","throwError","of","Observable","asyncScheduler","from","mergeMap","map","first","mapTo","takeWhile","tap","observeOn","catchError","JSONValidator","validate","data","schema","type","validateString","validateNumber","validateBoolean","validateArray","validateObject","validateConst","validateEnum","maxLength","undefined","length","minLength","pattern","regularExpression","RegExp","_a","test","Number","isInteger","multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","Array","isArray","maxItems","minItems","uniqueItems","dataSet","Set","size","items","validateTuple","value","schemas","i","Object","keys","properties","required","requiredProp","prototype","hasOwnProperty","call","property","const","enum","includes","ɵfac","ɵprov","args","providedIn","LS_PREFIX","factory","DEFAULT_IDB_DB_NAME","IDB_DB_NAME","DEFAULT_IDB_DB_VERSION","IDB_DB_VERSION","DEFAULT_IDB_STORE_NAME","IDB_STORE_NAME","DEFAULT_IDB_NO_WRAP","IDB_NO_WRAP","IDB_BROKEN_ERROR","IDBBrokenError","Error","constructor","arguments","message","SERIALIZATION_ERROR","SerializationError","IndexedDBDatabase","dbName","storeName","dbVersion","noWrap","database","wrapIndex","connect","backingStore","store","version","transaction","pipe","transactionData","events","request","count","result","get","key","set","delete","dataToStore","put","clear","openKeyCursor","success$","toString","continue","error$","listenError","has","getKey","indexedDB","open","error","createStore","subscribe","next","objectStoreNames","contains","createObjectStore","mode","objectStore","listenTransactionEvents","transactionOrRequest","event","target","complete$","decorators","LocalStorageDatabase","prefix","localStorage","unparsedData","getItem","prefixKey","parsedData","JSON","parse","serializedData","dataPrototype","getPrototypeOf","stringify","setItem","removeItem","subscriber","index","getUnprefixedKey","complete","prefixedKey","substr","MemoryDatabase","memoryStorage","Map","localDatabaseFactory","platformId","LSPrefix","IDBDBName","IDBStoreName","IDBDBVersion","IDBNoWrap","LocalDatabase","useFactory","deps","VALIDATION_ERROR","ValidationError","StorageMap","jsonValidator","notifiers","catchIDBBroken","backingEngine","fallbackBackingStore","notify","watch","notifier","asObservable","operationCallback","LocalStorage","storageMap","StorageModule","forRoot","config","ngModule","providers","provide","useValue","ɵmod","ɵinj"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { ReplaySubject, fromEvent, race, throwError, of, Observable, asyncScheduler, from } from 'rxjs';\nimport { mergeMap, map, first, mapTo, takeWhile, tap, observeOn, catchError } from 'rxjs/operators';\n\nclass JSONValidator {\n    /**\n     * Validate a JSON data against a Jsubset of the JSON Schema standard.\n     * Types are enforced to validate everything: each schema must\n     * @param data JSON data to validate\n     * @param schema Subset of JSON Schema. Must have a `type`.\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n     */\n    validate(data, schema) {\n        switch (schema.type) {\n            case 'string':\n                return this.validateString(data, schema);\n            case 'number':\n            case 'integer':\n                return this.validateNumber(data, schema);\n            case 'boolean':\n                return this.validateBoolean(data, schema);\n            case 'array':\n                return this.validateArray(data, schema);\n            case 'object':\n                return this.validateObject(data, schema);\n        }\n    }\n    /**\n     * Validate a string\n     * @param data Data to validate\n     * @param schema Schema describing the string\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateString(data, schema) {\n        if (typeof data !== 'string') {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        if (!this.validateEnum(data, schema)) {\n            return false;\n        }\n        if ((schema.maxLength !== undefined) && (data.length > schema.maxLength)) {\n            return false;\n        }\n        if ((schema.minLength !== undefined) && (data.length < schema.minLength)) {\n            return false;\n        }\n        if (schema.pattern) {\n            let regularExpression = null;\n            try {\n                regularExpression = new RegExp(schema.pattern);\n            }\n            catch (_a) {\n                // Nothing to do\n            }\n            if (regularExpression && !regularExpression.test(data)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a number or an integer\n     * @param data Data to validate\n     * @param schema Schema describing the number or integer\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateNumber(data, schema) {\n        if (typeof data !== 'number') {\n            return false;\n        }\n        if ((schema.type === 'integer') && !Number.isInteger(data)) {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        if (!this.validateEnum(data, schema)) {\n            return false;\n        }\n        /* Test is done this way to not divide by 0 */\n        if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {\n            return false;\n        }\n        if ((schema.maximum !== undefined) && (data > schema.maximum)) {\n            return false;\n        }\n        if ((schema.exclusiveMaximum !== undefined) && (data >= schema.exclusiveMaximum)) {\n            return false;\n        }\n        if ((schema.minimum !== undefined) && (data < schema.minimum)) {\n            return false;\n        }\n        if ((schema.exclusiveMinimum !== undefined) && (data <= schema.exclusiveMinimum)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Validate a boolean\n     * @param data Data to validate\n     * @param schema Schema describing the boolean\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateBoolean(data, schema) {\n        if (typeof data !== 'boolean') {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Validate an array\n     * @param data Data to validate\n     * @param schema Schema describing the array\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateArray(data, schema) {\n        if (!Array.isArray(data)) {\n            return false;\n        }\n        if ((schema.maxItems !== undefined) && (data.length > schema.maxItems)) {\n            return false;\n        }\n        if ((schema.minItems !== undefined) && (data.length < schema.minItems)) {\n            return false;\n        }\n        if (schema.uniqueItems) {\n            /* Create a set to eliminate values with multiple occurences */\n            const dataSet = new Set(data);\n            if (data.length !== dataSet.size) {\n                return false;\n            }\n        }\n        /* Specific test for tuples */\n        if (Array.isArray(schema.items)) {\n            // TODO: cast should not be needed here\n            return this.validateTuple(data, schema.items);\n        }\n        /* Validate all the values in array */\n        for (const value of data) {\n            // TODO: remove when TypeScript 4.1 is available\n            // (currently the narrowed type from `Array.isArray()` is lost on readonly arrays)\n            if (!this.validate(value, schema.items)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a tuple (array with fixed length and multiple types)\n     * @param data Data to validate\n     * @param schemas Schemas describing the tuple\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateTuple(data, schemas) {\n        /* Tuples have a fixed length */\n        if (data.length !== schemas.length) {\n            return false;\n        }\n        for (let i = 0; i < schemas.length; i += 1) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (!this.validate(data[i], schemas[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate an object\n     * @param data Data to validate\n     * @param schema JSON schema describing the object\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateObject(data, schema) {\n        /* Check the type and if not `null` as `null` also have the type `object` in old browsers */\n        if ((typeof data !== 'object') || (data === null)) {\n            return false;\n        }\n        /* Check if the object doesn't have more properties than expected\n         * Equivalent of `additionalProperties: false`\n         */\n        if (Object.keys(schema.properties).length < Object.keys(data).length) {\n            return false;\n        }\n        /* Validate required properties */\n        if (schema.required) {\n            for (const requiredProp of schema.required) {\n                if (!Object.prototype.hasOwnProperty.call(data, requiredProp)) {\n                    return false;\n                }\n            }\n        }\n        /* Recursively validate all properties */\n        for (const property in schema.properties) {\n            /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */\n            if (Object.prototype.hasOwnProperty.call(schema.properties, property) && Object.prototype.hasOwnProperty.call(data, property)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (!this.validate(data[property], schema.properties[property])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a constant\n     * @param data Data ta validate\n     * @param schema JSON schema describing the constant\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateConst(data, schema) {\n        if (!schema.const) {\n            return true;\n        }\n        return (data === schema.const);\n    }\n    /**\n     * Validate an enum\n     * @param data Data ta validate\n     * @param schema JSON schema describing the enum\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateEnum(data, schema) {\n        if (!schema.enum) {\n            return true;\n        }\n        /* Cast as the data can be of multiple types, and so TypeScript is lost */\n        return (schema.enum.includes(data));\n    }\n}\nJSONValidator.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: JSONValidator, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nJSONValidator.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: JSONValidator, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: JSONValidator, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\n/**\n * Token to provide a prefix to `localStorage` keys.\n */\nconst LS_PREFIX = new InjectionToken('localStoragePrefix', {\n    providedIn: 'root',\n    factory: () => ''\n});\n/**\n * Default name used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_NAME = 'ngStorage';\n/**\n * Token to provide `indexedDB` database name.\n */\nconst IDB_DB_NAME = new InjectionToken('localStorageIDBDBName', {\n    providedIn: 'root',\n    factory: () => DEFAULT_IDB_DB_NAME\n});\n/**\n * Default version used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_VERSION = 1;\n/**\n * Token to provide `indexedDB` database version.\n * Must be an unsigned **integer**.\n */\nconst IDB_DB_VERSION = new InjectionToken('localStorageIDBDBVersion', {\n    providedIn: 'root',\n    factory: () => DEFAULT_IDB_DB_VERSION\n});\n/**\n * Default name used for `indexedDB` object store.\n */\nconst DEFAULT_IDB_STORE_NAME = 'localStorage';\n/**\n * Token to provide `indexedDB` store name.\n * For backward compatibility, the default can't be set now, `IndexedDBDatabase` will do it at runtime.\n */\nconst IDB_STORE_NAME = new InjectionToken('localStorageIDBStoreName', {\n    providedIn: 'root',\n    factory: () => DEFAULT_IDB_STORE_NAME\n});\n/**\n * Default value for interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n */\nconst DEFAULT_IDB_NO_WRAP = true;\n/**\n * Token to allow interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n */\nconst IDB_NO_WRAP = new InjectionToken('localStorageIDBWrap', {\n    providedIn: 'root',\n    factory: () => DEFAULT_IDB_NO_WRAP\n});\n\n/**\n * Exception message when `indexedDB` is not working\n */\nconst IDB_BROKEN_ERROR = 'indexedDB is not working';\n/**\n * Exception raised when `indexedDB` is not working\n */\nclass IDBBrokenError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = IDB_BROKEN_ERROR;\n    }\n}\n/**\n * Exception message when a value can't be serialized for `localStorage`\n */\nconst SERIALIZATION_ERROR = `The storage is currently localStorage,\nwhere data must be serialized, and the provided data can't be serialized.`;\n/**\n * Exception raised when a value can't be serialized for `localStorage`\n */\nclass SerializationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = SERIALIZATION_ERROR;\n    }\n}\n\nclass IndexedDBDatabase {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param dbName `indexedDB` database name\n     * @param storeName `indexedDB` store name\n     * @param dbVersion `indexedDB` database version\n     * @param noWrap Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility\n     */\n    constructor(dbName = DEFAULT_IDB_DB_NAME, storeName = DEFAULT_IDB_STORE_NAME, dbVersion = DEFAULT_IDB_DB_VERSION, noWrap = DEFAULT_IDB_NO_WRAP) {\n        /**\n         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection\n         * even after the connection success event happened\n         */\n        this.database = new ReplaySubject(1);\n        /**\n         * Index used when wrapping value. *For backward compatibility only.*\n         */\n        this.wrapIndex = 'value';\n        this.dbName = dbName;\n        this.storeName = storeName;\n        this.dbVersion = dbVersion;\n        this.noWrap = noWrap;\n        /* Connect to `indexedDB`, with prefix if provided by the user */\n        this.connect();\n    }\n    /**\n     * Information about `indexedDB` connection. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version\n     */\n    get backingStore() {\n        return {\n            database: this.dbName,\n            store: this.storeName,\n            version: this.dbVersion,\n        };\n    }\n    /**\n     * Number of items in our `indexedDB` database and object store\n     */\n    get size() {\n        /* Open a transaction in read-only mode */\n        return this.transaction('readonly').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Request to know the number of items */\n            const request = store.count();\n            /* Return the result */\n            return events.pipe(map(() => request.result));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Gets an item value in our `indexedDB` store\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`\n     */\n    get(key) {\n        /* Open a transaction in read-only mode */\n        return this.transaction('readonly').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Request the value with the key provided by the user */\n            const request = store.get(key);\n            /* Listen events and return the result */\n            return events.pipe(map(() => {\n                if ((request.result !== undefined) && (request.result !== null)) {\n                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */\n                    if (!this.noWrap && (typeof request.result === 'object') && (this.wrapIndex in request.result) &&\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                        (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                        return request.result[this.wrapIndex];\n                    }\n                    else {\n                        /* Cast to the wanted type */\n                        return request.result;\n                    }\n                }\n                /* Return `undefined` if the value is empty */\n                return undefined;\n            }));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Sets an item in our `indexedDB` store\n     * @param key The item's key\n     * @param data The item's value\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */\n        if (data === undefined) {\n            return this.delete(key);\n        }\n        /* Open a transaction in write mode */\n        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Prior to v8, data was wrapped in a `{ value: ... }` object */\n            const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };\n            /* Add if the item is not existing yet, or update otherwise */\n            store.put(dataToStore, key);\n            /* Listen to events and return `undefined` as no value is expected */\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            return events.pipe(mapTo(undefined));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Deletes an item in our `indexedDB` store\n     * @param key The item's key\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        /* Open a transaction in write mode */\n        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Delete the item in store */\n            store.delete(key);\n            /* Listen to events and return `undefined` as no data is expected here */\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            return events.pipe(mapTo(undefined));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Deletes all items from our `indexedDB` objet store\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        /* Open a transaction in write mode */\n        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Delete all items in object store */\n            store.clear();\n            /* Listen to events and return `undefined` as no data is expected here */\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            return events.pipe(mapTo(undefined));\n        }), \n        /* The observable will complete */\n        first());\n    }\n    /**\n     * Get all the keys in our `indexedDB` store\n     * @returns An RxJS `Observable` iterating on each key\n     */\n    keys() {\n        /* Open a transaction in read-only mode */\n        return this.transaction('readonly').pipe(\n        /* `first()` is used as the final operator in other methods to complete the `Observable`\n         * (as it all starts from a `ReplaySubject` which never ends),\n         * but as this method is iterating over multiple values, `first()` **must** be used here */\n        first(), mergeMap((transactionData) => {\n            const { store } = transactionData;\n            /* Open a cursor on the store\n             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */\n            const request = store.openKeyCursor();\n            /* Listen to success event */\n            const success$ = fromEvent(request, 'success').pipe(\n            /* Stop the `Observable` when the cursor is `null` */\n            takeWhile(() => (request.result !== null)), \n            /* This lib only allows string keys, but user could have added other types of keys from outside\n             * It's OK to cast as the cursor as been tested in the previous operator */\n            map(() => request.result.key.toString()), \n            /* Iterate on the cursor */\n            tap(() => { request.result.continue(); }));\n            /* Listen to error event and if so, throw an error */\n            const error$ = this.listenError(request);\n            /* Choose the first event to occur */\n            return race([success$, error$]);\n        }));\n    }\n    /**\n     * Check if a key exists in our `indexedDB` store\n     * @returns An RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Open a transaction in read-only mode */\n        return this.transaction('readonly').pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Check if the key exists in the store\n             * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69\n             */\n            const request = store.getKey(key);\n            /* Listen to events and return `true` or `false` */\n            return events.pipe(map(() => (request.result !== undefined) ? true : false));\n        }), \n        /* The observable will complete */\n        first());\n    }\n    /**\n     * Connects to `indexedDB` and creates the object store on first time\n     */\n    connect() {\n        let request;\n        /* Connect to `indexedDB`\n         * Will fail in Safari cross-origin iframes\n         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */\n        try {\n            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */\n            request = indexedDB.open(this.dbName, this.dbVersion);\n        }\n        catch (_a) {\n            this.database.error(new IDBBrokenError());\n            return;\n        }\n        /* Create store on first connection */\n        this.createStore(request);\n        /* Listen to success and error events */\n        const success$ = fromEvent(request, 'success');\n        const error$ = this.listenError(request);\n        /* Choose the first to occur */\n        race([success$, error$])\n            /* The observable will complete */\n            .pipe(first())\n            .subscribe({\n            next: () => {\n                /* Register the database connection in the `ReplaySubject` for further access */\n                this.database.next(request.result);\n            },\n            error: () => {\n                /* Firefox private mode issue: fallback storage if IndexedDb connection is failing\n                * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n                * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */\n                this.database.error(new IDBBrokenError());\n            },\n        });\n    }\n    /**\n     * Create store on first use of `indexedDB`\n     * @param request `indexedDB` database opening request\n     */\n    createStore(request) {\n        /* Listen to the event fired on first connection */\n        fromEvent(request, 'upgradeneeded')\n            /* The observable will complete */\n            .pipe(first())\n            .subscribe({\n            next: () => {\n                /* Check if the store already exists, to avoid error */\n                if (!request.result.objectStoreNames.contains(this.storeName)) {\n                    /* Create the object store */\n                    request.result.createObjectStore(this.storeName);\n                }\n            }\n        });\n    }\n    /**\n     * Open an `indexedDB` transaction and get our store\n     * @param mode `readonly` or `readwrite`\n     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`\n     */\n    transaction(mode) {\n        /* From the `indexedDB` connection, open a transaction and get the store */\n        return this.database\n            .pipe(mergeMap((database) => {\n            let transaction;\n            try {\n                transaction = database.transaction([this.storeName], mode);\n            }\n            catch (error) {\n                /* The store could have been deleted from outside */\n                return throwError(error);\n            }\n            /* Get the store from the transaction */\n            const store = transaction.objectStore(this.storeName);\n            /* Listen transaction `complete` and `error` events */\n            const events = this.listenTransactionEvents(transaction);\n            return of({ store, events });\n        }));\n    }\n    /**\n     * Listen errors on a transaction or request, and throw if trigerred\n     * @param transactionOrRequest `indexedDb` transaction or request to listen\n     * @returns An `Observable` listening to errors\n     */\n    listenError(transactionOrRequest) {\n        return fromEvent(transactionOrRequest, 'error').pipe(\n        /* Throw on error to be able to catch errors in RxJS way.\n         * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`\n         * if we are on the request and the error is only triggered later by the transaction */\n        mergeMap((event) => throwError(event.target.error)));\n    }\n    /**\n     * Listen transaction `complete` and `error` events\n     * @param transaction Transaction to listen\n     * @returns An `Observable` listening to transaction `complete` and `error` events\n     */\n    listenTransactionEvents(transaction) {\n        /* Listen to the `complete` event */\n        const complete$ = fromEvent(transaction, 'complete');\n        /* Listen to the `error` event */\n        const error$ = this.listenError(transaction);\n        /* Choose the first event to occur */\n        return race([complete$, error$]);\n    }\n}\nIndexedDBDatabase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: IndexedDBDatabase, deps: [{ token: IDB_DB_NAME }, { token: IDB_STORE_NAME }, { token: IDB_DB_VERSION }, { token: IDB_NO_WRAP }], target: i0.ɵɵFactoryTarget.Injectable });\nIndexedDBDatabase.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: IndexedDBDatabase, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: IndexedDBDatabase, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [IDB_DB_NAME]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [IDB_STORE_NAME]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [IDB_DB_VERSION]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [IDB_NO_WRAP]\n                    }] }];\n    } });\n\nclass LocalStorageDatabase {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param prefix Prefix option to avoid collision for multiple apps on the same subdomain or for interoperability\n     */\n    constructor(prefix = '') {\n        /* Prefix if asked, or no prefix otherwise */\n        this.prefix = prefix || '';\n    }\n    /**\n     * Number of items in `localStorage`\n     */\n    get size() {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(localStorage.length);\n    }\n    /**\n     * Gets an item value in `localStorage`\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n    get(key) {\n        /* Get raw data */\n        const unparsedData = localStorage.getItem(this.prefixKey(key));\n        let parsedData;\n        /* No need to parse if data is `null` or `undefined` */\n        if ((unparsedData !== undefined) && (unparsedData !== null)) {\n            /* Try to parse */\n            try {\n                parsedData = JSON.parse(unparsedData);\n            }\n            catch (error) {\n                return throwError(error);\n            }\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(parsedData);\n    }\n    /**\n     * Store an item in `localStorage`\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        let serializedData = null;\n        /* Check if data can be serialized */\n        const dataPrototype = Object.getPrototypeOf(data);\n        if ((typeof data === 'object') && (data !== null) && !Array.isArray(data) &&\n            !((dataPrototype === Object.prototype) || (dataPrototype === null))) {\n            return throwError(new SerializationError());\n        }\n        /* Try to stringify (can fail on circular references) */\n        try {\n            serializedData = JSON.stringify(data);\n        }\n        catch (error) {\n            return throwError(error);\n        }\n        /* Can fail if storage quota is exceeded */\n        try {\n            localStorage.setItem(this.prefixKey(key), serializedData);\n        }\n        catch (error) {\n            return throwError(error);\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes an item in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        localStorage.removeItem(this.prefixKey(key));\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes all items in `localStorage`\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        localStorage.clear();\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Get all keys in `localStorage`\n     * Note the order of the keys may be inconsistent in Firefox\n     * @returns A RxJS `Observable` iterating on keys\n     */\n    keys() {\n        /* Create an `Observable` from keys */\n        return new Observable((subscriber) => {\n            /* Iteretate over all the indexes */\n            for (let index = 0; index < localStorage.length; index += 1) {\n                /* Cast as we are sure in this case the key is not `null` */\n                subscriber.next(this.getUnprefixedKey(index));\n            }\n            subscriber.complete();\n        }).pipe(\n        /* Required to work like other databases which are asynchronous */\n        observeOn(asyncScheduler));\n    }\n    /**\n     * Check if a key exists in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Itérate over all indexes in storage */\n        for (let index = 0; index < localStorage.length; index += 1) {\n            if (key === this.getUnprefixedKey(index)) {\n                /* Wrap in a RxJS `Observable` to be consistent with other storages */\n                return of(true);\n            }\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(false);\n    }\n    /**\n     * Get an unprefixed key\n     * @param index Index of the key\n     * @returns The unprefixed key name if exists, `null` otherwise\n     */\n    getUnprefixedKey(index) {\n        /* Get the key in storage: may have a prefix */\n        const prefixedKey = localStorage.key(index);\n        if (prefixedKey !== null) {\n            /* If no prefix, the key is already good, otherwrite strip the prefix */\n            return !this.prefix ? prefixedKey : prefixedKey.substr(this.prefix.length);\n        }\n        return null;\n    }\n    /**\n     * Add the prefix to a key\n     * @param key The key name\n     * @returns The prefixed key name\n     */\n    prefixKey(key) {\n        return `${this.prefix}${key}`;\n    }\n}\nLocalStorageDatabase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalStorageDatabase, deps: [{ token: LS_PREFIX }], target: i0.ɵɵFactoryTarget.Injectable });\nLocalStorageDatabase.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalStorageDatabase, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalStorageDatabase, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [LS_PREFIX]\n                    }] }];\n    } });\n\nclass MemoryDatabase {\n    constructor() {\n        /**\n         * Memory storage\n         */\n        this.memoryStorage = new Map();\n    }\n    /**\n     * Number of items in memory\n     */\n    get size() {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(this.memoryStorage.size);\n    }\n    /**\n     * Gets an item value in memory\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n    get(key) {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(this.memoryStorage.get(key));\n    }\n    /**\n     * Sets an item in memory\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        this.memoryStorage.set(key, data);\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes an item in memory\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        this.memoryStorage.delete(key);\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes all items in memory\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        this.memoryStorage.clear();\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Get all keys in memory\n     * @returns A RxJS `Observable` iterating on keys\n     */\n    keys() {\n        /* Create an `Observable` from keys */\n        return from(this.memoryStorage.keys());\n    }\n    /**\n     * Check if a key exists in memory\n     * @param key Key name\n     * @returns a RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(this.memoryStorage.has(key));\n    }\n}\nMemoryDatabase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: MemoryDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nMemoryDatabase.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: MemoryDatabase, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: MemoryDatabase, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\n/**\n * Factory to create a storage according to browser support\n * @param platformId Context about the platform (`browser`, `server`...)\n * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain\n * @param IDBDBName `indexedDB` database name\n * @param IDBstoreName `indexedDB` storeName name\n * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}\n */\nfunction localDatabaseFactory(platformId, LSPrefix, IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap) {\n    /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n     * just trying to check `indexedDB` or `localStorage` variables causes a security exception.\n     * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n     */\n    try {\n        // Do not explicit `window` here, as the global object is not the same in web workers\n        if (isPlatformBrowser(platformId) && (indexedDB !== undefined) && (indexedDB !== null) && ('open' in indexedDB)) {\n            /* Check:\n            * - if we are in a browser context (issue: server-side rendering)\n            * - it could exist but be `undefined` or `null`\n            * - it could exists but not having a working API\n            * Will be the case for:\n            * - All other browsers in normal mode\n            * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */\n            return new IndexedDBDatabase(IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap);\n        }\n        else if (isPlatformBrowser(platformId)\n            && (localStorage !== undefined) && (localStorage !== null) && ('getItem' in localStorage)) {\n            /* Check:\n            * - if we are in a browser context (issue: server-side rendering)\n            * - if `localStorage` exists (to be sure)\n            * - it could exists but not having a working API\n            * Will be the case for:\n            * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`\n            * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}\n            * - Firefox private mode, but in this case, data will be swiped when the user leaves the app\n            * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`\n            * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n            */\n            return new LocalStorageDatabase(LSPrefix);\n        }\n    }\n    catch (_a) {\n        // Nothing to do\n    }\n    /* Will be the case for:\n     * - In browsers if storage has been fully disabled (via the \"Block all cookies\" option)\n     * - Server-side rendering\n     * - All other non-browser context\n     */\n    return new MemoryDatabase();\n}\nclass LocalDatabase {\n}\nLocalDatabase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nLocalDatabase.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalDatabase, providedIn: 'root', useFactory: localDatabaseFactory, deps: [{ token: PLATFORM_ID }, { token: LS_PREFIX }, { token: IDB_DB_NAME }, { token: IDB_STORE_NAME }, { token: IDB_DB_VERSION }, { token: IDB_NO_WRAP }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalDatabase, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                    useFactory: localDatabaseFactory,\n                    deps: [\n                        PLATFORM_ID,\n                        LS_PREFIX,\n                        IDB_DB_NAME,\n                        IDB_STORE_NAME,\n                        IDB_DB_VERSION,\n                        IDB_NO_WRAP,\n                    ]\n                }]\n        }] });\n\n/**\n * Exception message when a value is not valid against the JSON schema\n */\nconst VALIDATION_ERROR = `Data stored is not valid against the provided JSON schema.\nCheck your JSON schema, otherwise it means data has been corrupted.`;\n/**\n * Exception raised when a value is not valid against the JSON schema\n */\nclass ValidationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = VALIDATION_ERROR;\n    }\n}\n\nclass StorageMap {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param database Storage to use\n     * @param jsonValidator Validator service\n     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability\n     */\n    constructor(database, jsonValidator = new JSONValidator(), LSPrefix = '') {\n        this.database = database;\n        this.jsonValidator = jsonValidator;\n        this.LSPrefix = LSPrefix;\n        this.notifiers = new Map();\n    }\n    /**\n     * **Number of items** in storage, wrapped in an `Observable`.\n     *\n     * @example\n     * this.storageMap.size.subscribe((size) => {\n     *   console.log(size);\n     * });\n     */\n    get size() {\n        return this.database.size\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.size));\n    }\n    /**\n     * Tells you which storage engine is used. *Only useful for interoperability.*\n     * Note that due to some browsers issues in some special contexts\n     * (Firefox private mode and Safari cross-origin iframes),\n     * **this information may be wrong at initialization,**\n     * as the storage could fallback from `indexedDB` to `localStorage`\n     * only after a first read or write operation.\n     * @returns Storage engine used\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {}\n     */\n    get backingEngine() {\n        if (this.database instanceof IndexedDBDatabase) {\n            return 'indexedDB';\n        }\n        else if (this.database instanceof LocalStorageDatabase) {\n            return 'localStorage';\n        }\n        else if (this.database instanceof MemoryDatabase) {\n            return 'memory';\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    /**\n     * Info about `indexedDB` database. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version.\n     * **Values will be empty if the storage is not `indexedDB`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {\n     *   const { database, store, version } = this.storageMap.backingStore;\n     * }\n     */\n    get backingStore() {\n        return (this.database instanceof IndexedDBDatabase) ?\n            this.database.backingStore :\n            { database: '', store: '', version: 0 };\n    }\n    /**\n     * Info about `localStorage` fallback storage. *Only useful for interoperability.*\n     * @returns `localStorage` prefix.\n     * **Values will be empty if the storage is not `localStorage`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'localStorage') {\n     *   const { prefix } = this.storageMap.fallbackBackingStore;\n     * }\n     */\n    get fallbackBackingStore() {\n        return (this.database instanceof LocalStorageDatabase) ?\n            { prefix: this.database.prefix } :\n            { prefix: '' };\n    }\n    get(key, schema) {\n        /* Get the data in storage */\n        return this.database.get(key).pipe(\n        /* Check if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.get(key)), mergeMap((data) => {\n            /* No need to validate if the data is empty */\n            if ((data === undefined) || (data === null)) {\n                return of(undefined);\n            }\n            else if (schema) {\n                /* Validate data against a JSON schema if provided */\n                if (!this.jsonValidator.validate(data, schema)) {\n                    return throwError(new ValidationError());\n                }\n                /* Data have been checked, so it's OK to cast */\n                return of(data);\n            }\n            /* Cast to unknown as the data wasn't checked */\n            return of(data);\n        }));\n    }\n    /**\n     * Set an item in storage.\n     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n     * @param key The item's key\n     * @param data The item's value\n     * @param schema Optional JSON schema to validate the data\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.set('key', 'value').subscribe(() => {});\n     */\n    set(key, data, schema) {\n        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,\n         * so removing item instead for all storages to have a consistent API */\n        if ((data === undefined) || (data === null)) {\n            return this.delete(key);\n        }\n        /* Validate data against a JSON schema if provided */\n        if (schema && !this.jsonValidator.validate(data, schema)) {\n            return throwError(new ValidationError());\n        }\n        return this.database.set(key, data).pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.set(key, data)), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => { this.notify(key, data); }));\n    }\n    /**\n     * Delete an item in storage\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.delete('key').subscribe(() => {});\n     */\n    delete(key) {\n        return this.database.delete(key).pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.delete(key)), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => { this.notify(key, undefined); }));\n    }\n    /**\n     * Delete all items in storage\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.clear().subscribe(() => {});\n     */\n    clear() {\n        return this.database.clear().pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.clear()), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => {\n            for (const key of this.notifiers.keys()) {\n                this.notify(key, undefined);\n            }\n        }));\n    }\n    /**\n     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:\n     * * if there is no key, the `next` callback will not be invoked,\n     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,\n     * as this `Observable` can emit several values and so will invoke the `next` callback several times.\n     * @returns A list of the keys wrapped in a RxJS `Observable`\n     *\n     * @example\n     * this.storageMap.keys().subscribe({\n     *   next: (key) => { console.log(key); },\n     *   complete: () => { console.log('Done'); },\n     * });\n     */\n    keys() {\n        return this.database.keys()\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.keys()));\n    }\n    /**\n     * Tells if a key exists in storage\n     * @returns A RxJS `Observable` telling if the key exists\n     *\n     * @example\n     * this.storageMap.has('key').subscribe((hasKey) => {\n     *   if (hasKey) {}\n     * });\n     */\n    has(key) {\n        return this.database.has(key)\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.has(key)));\n    }\n    watch(key, schema) {\n        /* Check if there is already a notifier */\n        if (!this.notifiers.has(key)) {\n            this.notifiers.set(key, new ReplaySubject(1));\n        }\n        /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const notifier = this.notifiers.get(key);\n        /* Get the current item value */\n        (schema ? this.get(key, schema) : this.get(key)).subscribe({\n            next: (result) => notifier.next(result),\n            error: (error) => notifier.error(error),\n        });\n        /* Only the public API of the `Observable` should be returned */\n        return (schema ?\n            notifier.asObservable() :\n            notifier.asObservable());\n    }\n    /**\n     * Notify when a value changes\n     * @param key The item's key\n     * @param data The new value\n     */\n    notify(key, value) {\n        const notifier = this.notifiers.get(key);\n        if (notifier) {\n            notifier.next(value);\n        }\n    }\n    /**\n     * RxJS operator to catch if `indexedDB` is broken\n     * @param operationCallback Callback with the operation to redo\n     */\n    catchIDBBroken(operationCallback) {\n        return catchError((error) => {\n            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */\n            if ((error !== undefined) && (error !== null)\n                && (typeof error === 'object') && ('message' in error)\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                && (error.message === IDB_BROKEN_ERROR)) {\n                /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n                 * just trying to check `localStorage` variable causes a security exception.\n                 * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n                 */\n                try {\n                    if ('getItem' in localStorage) {\n                        /* Fallback to `localStorage` if available */\n                        this.database = new LocalStorageDatabase(this.LSPrefix);\n                    }\n                    else {\n                        /* Fallback to memory storage otherwise */\n                        this.database = new MemoryDatabase();\n                    }\n                }\n                catch (_a) {\n                    /* Fallback to memory storage otherwise */\n                    this.database = new MemoryDatabase();\n                }\n                /* Redo the operation */\n                return operationCallback();\n            }\n            else {\n                /* Otherwise, rethrow the error */\n                return throwError(error);\n            }\n        });\n    }\n}\nStorageMap.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: StorageMap, deps: [{ token: LocalDatabase }, { token: JSONValidator }, { token: LS_PREFIX }], target: i0.ɵɵFactoryTarget.Injectable });\nStorageMap.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: StorageMap, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: StorageMap, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: function () {\n        return [{ type: LocalDatabase }, { type: JSONValidator }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [LS_PREFIX]\n                    }] }];\n    } });\n\nclass LocalStorage {\n    /* Use the `StorageMap` service to avoid code duplication */\n    constructor(storageMap) {\n        this.storageMap = storageMap;\n    }\n    /**\n     * Number of items in storage wrapped in an `Observable`\n     *\n     * @example\n     * this.localStorage.length.subscribe((length) => {\n     *   console.log(length);\n     * });\n     */\n    get length() {\n        return this.storageMap.size;\n    }\n    getItem(key, schema) {\n        if (schema) {\n            /* Backward compatibility with version <= 7 */\n            schema = ('schema' in schema) ? schema.schema : schema;\n        }\n        return (schema ? this.storageMap.get(key, schema) : this.storageMap.get(key)).pipe(\n        /* Transform `undefined` into `null` to align with `localStorage` API */\n        map((value) => (value !== undefined) ? value : null));\n    }\n    /**\n     * Set an item in storage.\n     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n     * @param key The item's key\n     * @param data The item's value\n     * @param schema Optional JSON schema to validate the data\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.set('key', 'value').subscribe(() => {});\n     */\n    setItem(key, data, schema) {\n        return this.storageMap.set(key, data, schema).pipe(\n        /* Transform `undefined` into `true` for backward compatibility with v7 */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        mapTo(true));\n    }\n    /**\n     * Delete an item in storage\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.delete('key').subscribe(() => {});\n     */\n    removeItem(key) {\n        return this.storageMap.delete(key).pipe(\n        /* Transform `undefined` into `true` for backward compatibility with v7 */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        mapTo(true));\n    }\n    /**\n     * Delete all items in storage\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.clear().subscribe(() => {});\n     */\n    clear() {\n        return this.storageMap.clear().pipe(\n        /* Transform `undefined` into `true` for backward compatibility with v7 */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        mapTo(true));\n    }\n}\nLocalStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalStorage, deps: [{ token: StorageMap }], target: i0.ɵɵFactoryTarget.Injectable });\nLocalStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalStorage, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: LocalStorage, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: function () { return [{ type: StorageMap }]; } });\n\n/**\n * This module does not contain anything, it's only useful to provide options via `.forRoot()`.\n */\nclass StorageModule {\n    /**\n     * Only useful to provide options, otherwise it does nothing.\n     * **Must be used at initialization, ie. in `AppModule`, and must not be loaded again in another module.**\n     *\n     * @example\n     * NgModule({\n     *   imports: [StorageModule.forRoot({\n     *     LSPrefix: 'custom_',\n     *   })]\n     * })\n     * export class AppModule\n     */\n    static forRoot(config) {\n        return {\n            ngModule: StorageModule,\n            providers: [\n                config.LSPrefix ? { provide: LS_PREFIX, useValue: config.LSPrefix } : [],\n                config.IDBDBName ? { provide: IDB_DB_NAME, useValue: config.IDBDBName } : [],\n                config.IDBStoreName ? { provide: IDB_STORE_NAME, useValue: config.IDBStoreName } : [],\n                config.IDBDBVersion ? { provide: IDB_DB_VERSION, useValue: config.IDBDBVersion } : [],\n                (config.IDBNoWrap === false) ? { provide: IDB_NO_WRAP, useValue: config.IDBNoWrap } : [],\n            ],\n        };\n    }\n}\nStorageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: StorageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nStorageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: StorageModule });\nStorageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: StorageModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.3\", ngImport: i0, type: StorageModule, decorators: [{\n            type: NgModule\n        }] });\n\n/*\n * Public API Surface of local-storage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JSONValidator, LocalDatabase, LocalStorage, SERIALIZATION_ERROR, SerializationError, StorageMap, StorageModule, VALIDATION_ERROR, ValidationError };\n"]},"metadata":{},"sourceType":"module"}